:const c_jumpHeight      -15
:const c_gravityStrength  2

:alias a_temp      vd
:alias a_counter   vc
:alias a_partialDY v7


#################################
#
#  Player Data
#

:alias a_playerX             v0
:alias a_playerY             v1
:alias a_playerPrevX         v2
:alias a_playerPrevY         v3
:alias a_playerSpeedX        v4
:alias a_playerSpeedY        v5
:alias a_playerJumpAvailable v6

: player
: playerCoords
: playerX
	5
: playerY
	0

: playerPrevCoords
: playerPrevX
	5
: playerPrevY
	0

: playerSpeed
: playerSpeedX
	0
: playerSpeedY
	0

: playerJumpAvailable
	0


#################################
#
#  Level Data
#

:alias a_bgx       v0
:alias a_bgy       v1
:alias a_bgTicker  v2

: level
: background
: bgX
	0
: bgY
	0

: bgTicker
	0


#################################
#
#  Game Loop
#

: main
	hires
	loop
		f_checkScrolling
		f_input
		f_checkCollisionH
		f_gravity
		f_checkCollisionV
		f_delayFPS

		# undraw player before next movement
		#   this would be nicer if it could be easily moved into
		#   the movement logic
		i := player
		load v2
		f_drawAmy
	again
;

: f_checkScrolling
	push
	i := player
	load a_playerY

	# when player gets too far down, scroll up and draw more level 
	if a_playerY > 30 begin
		f_scroll
	end

	pop
;

: f_input
	push
	i := player
	load v6

	# store the previous x position in case of collision
	a_playerPrevX := a_playerX

	a_temp := 5
	if a_temp key then if a_playerJumpAvailable == 1 begin
		a_playerJumpAvailable := 0
    a_playerSpeedY := c_jumpHeight
	end
	a_temp := 7 if a_temp key then a_playerX += -1
	a_temp := 9 if a_temp key then a_playerX += 1

	i := player
	save v6
	pop
;

# this function does NOT use push/pop because that affects vf and
# drawing is used for collision detection. it instead relies on
# a_playerX and a_playerY being set appropriately by the calling function
: f_drawAmy
	i := amy
	sprite a_playerX a_playerY 6
;

: f_drawAmyPrev
	i := amy
	sprite a_playerPrevX a_playerPrevY 6
;

: f_checkCollisionH
	push
	i := player
	load v6

	f_drawAmy
	if vf == 1 begin
		f_drawAmy
		a_playerX := a_playerPrevX
		f_drawAmy
	end

	i := player
	save v6
	pop
;

: f_gravity
	push
	i := player
	load v6

	a_playerSpeedY += c_gravityStrength

	i := player
	save v6
	pop
;

: f_checkCollisionV
	push
	i := player
	load v6

	# a_temp is the direction the player is traveling

	# a_partialDY is shifted right twice from actual DY.
	# a_partialDY is what's actually used to calculate the new position.
	# this is so playerSpeedY can be increased or decreased more finely
	# might want to do that same with playerY also?

	# < 128 is (probably) positive and > 128 is (probably) negative

	if a_playerSpeedY < 128 begin
		a_temp := 1
		a_partialDY >>= a_playerSpeedY
		a_partialDY >>= a_partialDY
	end 

	if a_playerSpeedY > 128 begin
		a_temp := -1
		a_partialDY >>= a_playerSpeedY
		a_partialDY >>= a_partialDY
		a_partialDY += 0b11000000
	end
	
	if a_partialDY == 0 then jump j_checkCollisionV_return

	# collide slowly-
	# undraw amy, redraw amy one pixel in the y direction and see if she collides
	# if she ever does, revert back one position and exit
	
	loop	
		f_drawAmy
		a_partialDY -= a_temp
		a_playerY += a_temp
		f_drawAmy
		if vf != 0 begin
			if a_temp == 1 then a_playerJumpAvailable := 1
			a_playerSpeedY := 0
			f_drawAmy
			a_playerY -= a_temp
			f_drawAmy
			jump j_checkCollisionV_return
		end
	if a_partialDY != 0 then again

: j_checkCollisionV_return
	i := player
	save v6
	pop
;

: f_delayFPS
	# delay loop to lock framerate and prevent flicker
	loop
		vf := delay
		if vf != 0 then again
	vf := 3
	delay := vf
;

: f_scroll
	push
	i := player
	load a_playerY

	a_playerY += -30
	scroll-up 15
	scroll-up 15
	f_drawBG

	i := player
	save a_playerY
	pop
;

: f_drawBG
	push
	i := level
	load v2

	# drawing pixels to walk on!
	i := main
	a_temp := random 0b0001111
	i += a_temp
	a_temp := 0
	a_bgx := 0
	if a_bgTicker == 1 then a_bgx := 16
	a_bgy := 54
	loop
		sprite a_bgx a_bgy 8
		a_bgx += 8
		a_temp += 1
	if a_temp < 14 then again
	a_temp := a_bgTicker
	a_bgTicker := 1
	a_bgTicker -= a_temp

	i := level
	save v2
	pop
;

: amy
0b111
0b010
0b111
0b111
0b101
0b101


#################################
#
#  stack
#   (don't touch this)
#

:const stacklimit 196             # this should be a multiple of 14

: stack-pointer
	0 0

: stack
	0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0

: stack-buffer                     # catch a potential stack overflow
	0 0 0 0 0 0 0 0 0 0 0 0 0 0

: push
	i := stack-pointer
	load ve - ve

	# don't overflow the stack
	if ve == stacklimit begin
		:breakpoint warning-stack-overflow
		return
	end

	i := stack
	i += ve
	save v0 - vd

	# increment the stack pointer
	ve += 14
	i := stack-pointer
	save ve - ve
;

: pop
	i := stack-pointer
	load ve - ve

  # if the stack pointer is 0 there is nothing to pop
	if ve == 0 begin
		:breakpoint warning-stack-underflow
		return
	end

	# decrement the stack pointer
	ve += -14
	save ve - ve

	i := stack
	i += ve
	load v0 - vd
;
